##Pipline-manager
Код в main получает и проверяет аргументы командной строки (в args ровно один строковый литерал).
После этого отдает этот аргумент (имя конфигурационного файла со определением конвейера) коду класса Manager (не важно, статическому методу или в конструктор).
В этом конфиге должны быть определены:
- имя входного файла, который должен быть открыт кодом Manager, а ссылку на открытый входной поток Manager должен передать Reader'у, для этого Reader должен был имлементировать интерфейс IReader (в котором пока единственный метод setInputStream)
- имя конфигурационного файла для экземпляра Reader'а
- имя выходного файла, который должен быть открыт кодом Manager, а ссылку на открытый выходной поток Manager должен передать Writer'у, для этого Writer должен был имлементировать интерфейс IWriter (в котором пока единственный метод setOutputStream)
- имя конфигурационного файла для экземпляра Writer'а
- канонические имена классов всех экзекьюторов вместе с именами их конфигурационных файлов,
- порядок расстановки экзекьюторов на конвейере

Если разбор конфига (синтаксический только!) Manager'ом завершился успешно, то результат разбора в форме некоторого контейнера передается коду этого же класса, чтобы построить конвейер и сконфигурировать всех экзекьюторов, включая Reader и Writer'а.
Код класса Manager сначала выполняет семантический разбор параметров из конфига, которые параметризуют конвейер/сессию этого приложения (если файл со входными данными, то он существует и открывается на чтение, если файл для результатов, то он тоже открывается, но для записи).
Реализация семантического разбора может быть набором статических методов или методов экземпляра класса.
Далее Manager конструирует (используя механизм интроспекции) и расставляет на конвейере всех экзекьюторов, включая Reader и Writer'а.
Наконец, он инициирует работу конвейера, вызвав у Reader'а метод execute(null) (этот метод Reader должен реализовать вместе с остальными методами интерфейса IExecutor).
Работа конвейера завершается, когда Reader вернет управление из метода execute(null).
Далее анализ кода возврата кодом Manager, он пишет что-то в лог (саксесс или были проблемы),
и завершаем работу конвейера.

#ОБЩИЕ ТРЕБОВАНИЯ ОСТАЮТСЯ ПРЕЖНИМИ
Грамматика конфигов ВСЕХ КЛАССОВ должна быть оформлена в самостоятельные статические неизменяемые (final) контейнеры.
В  коде никаких волшебных строковых литералов и волшебных чисел.
Код не кидает никаких исключений. Если их кинул какой-то метод из стандартных библиотек, то тут  же обработать, выдав пользователю в консоли (позже - в лог) вразумительное сообщение (не стек трейс!).

#СТРУКТУРА ПРОЕКТОВ
В качестве итога работы четыре проекта:
1. Проект, в котором чистый Reader, включая классы парсеров его конфига (синтаксический и семантический), но никаких примесей менеджеров, экзекьюторов, райтеров.
 Это проект нужен для того, чтобы собрать в jar-файл реализацию этого компонента конвейера.
2. Проект, в котором чистый Writer, включая классы парсеров его конфига (синтаксический и семантический), но никаких примесей менеджеров, экзекьюторов, ридеров.
 Это проект нужен для того, чтобы собрать в jar-файл реализацию этого компонента конвейера.
3. Проект, в котором чистый Executor, включая классы парсеров его конфига (синтаксический и семантический), но никаких примесей менеджеров, ридеров, райтеров.
 Это проект нужен для того, чтобы собрать в jar-файл реализацию этого компонента конвейера.
4. Проект, в котором чистый Manager конвейера, включая классы парсеров его конфига (синтаксический и семантический), но никаких примесей экзекьюторов, ридеров, райтеров.
 Это проект нужен для того, чтобы поместить в него jar-файлы с реализациями всех компонент конвейера и собрать конвейер.
В этом проекте в структуре каталогов на том же уровне, что и каталог src:
создать каталого artefacts, в который поместить три СВОИХ компоненты: reader.jar, executor.jar, writer.jar
создать каталого libs, в который поместить три ЧЬИХ-то (очевидно, не своих) компоненты: XXXreader.jar, XXXexecutor.jar, XXXwriter.jar
создать каталого configs, в который поместить четыре конфига конвейеров:
1) конвейер, собранный только из своих компонент (из jar-ников reader.jar, executor.jar, writer.jar из каталога artefacts)
2) конвейер, собранный из своих компонент за исключением Reader'а (ридер чужой из jar-ников каталога libs)
3) конвейер, собранный из своих компонент за исключением Writer'а (райтер чужой из jar-ников каталога libs)
4) конвейер, собранный из своих компонент с добавлением парочки чужих Executor'ов (к своим экзекьюторам прибавить чужие из jar-ников каталога libs)

